import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.ProtocolException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.util.Base64;
import java.util.ArrayList; // Added for dynamic list of mentions
import java.util.HashSet; // Added for efficient tracking of processed IDs
import java.util.List; // Interface for ArrayList
import java.util.Set; // Interface for HashSet

import org.json.JSONArray;
import org.json.JSONObject;

public class Main {

	String token = "";
	LocalDateTime token_exp = null;

	final String user_agent = "script_in_java:h-counter-bot:v1 (by u/PROMAN8625)";

	// Environment variables for sensitive credentials
	final String clientId = System.getenv("h_bot_id");
	final String clientSecret = System.getenv("h_bot_secret");
	final String username = System.getenv("h_bot_username");
	final String password = System.getenv("h_bot_pass");

	// Set to store IDs of messages that have been processed (replied to or skipped)
	private Set<String> processedMessageFullnames = new HashSet<>();
	private final String PROCESSED_IDS_FILE = "/home/hridaykh/Desktop/aaaa.txt"; // File to store processed fullnames

	public static void main(String[] args) {
		new Main();
	}

	public Main() {
		loadProcessedMessageFullnames(); // Load processed IDs on startup
		while (true) {
			try {
				update_loop();
				Thread.sleep(3000); // 3 seconds
			} catch (InterruptedException e) {
				Thread.currentThread().interrupt();
				System.err.println("Bot interrupted: " + e.getMessage());
				break;
			}
		}
	}

	public void update_loop() {
		LocalDateTime rn = LocalDateTime.now();
		// Check if token is null, expired, or about to expire (within 1 minute)
		if (token == null || token_exp == null || rn.isAfter(token_exp.minusMinutes(1))) {
			System.out.println("Access token is missing or expired, attempting to refresh...");
			// Correct way to assign the token. getAccessToken() already returns the string.
			String newToken = getAccessToken();
			if (newToken != null) {
				token = newToken;
				// Reddit tokens typically expire in 3600 seconds (1 hour).
				// Using 86400 (24 hours) might be too long if Reddit enforces shorter expiry.
				token_exp = rn.plusSeconds(3600); // Set expiry to 1 hour from now
				System.out.println("Access token refreshed successfully. Expires at: " + token_exp);
			} else {
				System.err.println("Failed to obtain access token. Cannot proceed with update loop.");
				return; // Exit if token cannot be obtained
			}
		}

		// Get all unread messages (mentions, DMs, etc.)
		List<String[]> unreadMentions = getUnreadMessagesAndFilterMentions();

		for (String[] mention : unreadMentions) {
			// Basic validation for the structure of a mention array
			if (mention.length < 3) {
				System.err.println("Skipping malformed mention array: " + String.join(",", mention));
				continue;
			}

			String id = mention[0]; // The base ID (e.g., "n1lqt5s")
			String author = mention[1]; // The author of the mention
			String type = mention[2]; // The user being queried (e.g., "PROMAN8625")
			String fullname = mention[3]; // The full ID (e.g., "t1_n1lqt5s")

			System.out.println("Processing Mention ID: " + id + ", Author: " + author + ", Target User: " + type);

			// Fetch comments for the target user (type)
			String[] comments = getUserComments(type);
			long[] inf = getCommentInfo(comments);
			long totalChars = inf[0];
			long totalH = inf[1];
			long totalComments = comments.length;

			String result;
			if (totalChars - totalH == 0) {
				// Handle division by zero for H-Score
				result = "User " + author + " is curious about the h count of u/" + type + ".\nu/" + type + " has made "
						+ totalComments + " comments with a total of " + totalChars + " characters, containing "
						+ totalH
						+ " 'h' characters.\nThat comes out to a total H-Score - i.e. H/not H - **200**! This means this user has only used 'h' characters in their comments!\n"
						+ "\n\nThis message was generated by the H-Counter Bot. If you have any questions, please contact u/PROMAN8625.";
			} else {
				// Calculate H-Score as a double for precision
				double hScore = (double) totalH / (totalChars - totalH);
				result = "User " + author + " is curious about the h count of u/" + type + ".\nu/" + type + " has made "
						+ totalComments + " comments with a total of " + totalChars + " characters, containing "
						+ totalH + " 'h' characters.\nThat comes out to a total H-Score - i.e. H/not H - of **"
						+ String.format("%.2f", hScore * 100) // Format to 4 decimal places
						+ "**!\n\nThis message was generated by the H-Counter Bot. If you have any questions, please contact u/PROMAN8625.";
			}

			try {
				// Reply to the comment using its base ID
				boolean success = replyToComment(id, result);
				if (success) {
					System.out.println("Successfully sent reply to mention ID: " + id);
					// Mark the original mention as read after successful reply
					boolean markedRead = markMessageAsRead(fullname);
					if (markedRead) {
						System.out.println("Successfully marked mention as read: " + fullname);
						processedMessageFullnames.add(fullname); // Add to our set
						saveProcessedMessageFullnames(); // Persist the updated set
					} else {
						System.err.println("Failed to mark mention as read: " + fullname);
					}
				} else {
					System.err.println("Failed to send reply to mention ID: " + id);
				}
			} catch (Exception e) {
				System.err.println(
						"An error occurred during reply or marking as read for ID " + id + ": " + e.getMessage());
				e.printStackTrace();
			}
		}
	}

	/**
	 * Marks a message (comment, DM, etc.) as read on Reddit.
	 *
	 * @param fullname The full ID of the message to mark as read (e.g.,
	 *                 "t1_abcdef", "t4_123456").
	 * @return true if the message was successfully marked as read, false otherwise.
	 */
	public boolean markMessageAsRead(String fullname) {
		HttpURLConnection conn = null;
		try {
			URL url = new URI("https://oauth.reddit.com/api/read_message").toURL();
			conn = (HttpURLConnection) url.openConnection();

			conn.setRequestMethod("POST");
			conn.setDoOutput(true); // POST request, so output is expected
			conn.setRequestProperty("Authorization", "Bearer " + token);
			conn.setRequestProperty("User-Agent", user_agent);
			conn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");

			String postBody = "id=" + URLEncoder.encode(fullname, StandardCharsets.UTF_8.toString());

			try (OutputStream os = conn.getOutputStream()) {
				os.write(postBody.getBytes(StandardCharsets.UTF_8));
			}

			int responseCode = conn.getResponseCode();
			System.out.println("Mark as Read HTTP Response Code for " + fullname + ": " + responseCode);

			// Read the response body for debugging, even on non-200 codes
			try (BufferedReader in = new BufferedReader(new InputStreamReader(
					responseCode >= 200 && responseCode < 300 ? conn.getInputStream() : conn.getErrorStream()))) {
				String line;
				StringBuilder responseBody = new StringBuilder();
				while ((line = in.readLine()) != null) {
					responseBody.append(line);
				}
				System.out.println("Mark as Read Response Body: " + responseBody.toString());
			}

			return responseCode == HttpURLConnection.HTTP_OK; // Reddit returns 200 OK on success
		} catch (Exception e) {
			System.err.println("Error marking message as read: " + e.getMessage());
			e.printStackTrace();
			return false;
		} finally {
			if (conn != null) {
				conn.disconnect();
			}
		}
	}

	/**
	 * Replies to a Reddit comment.
	 *
	 * @param thingId   The ID of the comment to reply to (e.g., "n1lqt5s").
	 * @param replyText The text of the reply.
	 * @return true if the reply was successfully posted, false otherwise.
	 */
	public boolean replyToComment(String thingId, String replyText) {
		HttpURLConnection conn = null;
		try {
			URL url = new URI("https://oauth.reddit.com/api/comment").toURL();
			conn = (HttpURLConnection) url.openConnection();

			conn.setRequestMethod("POST");
			conn.setDoOutput(true);
			conn.setRequestProperty("Authorization", "Bearer " + token);
			conn.setRequestProperty("User-Agent", user_agent);
			conn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");

			// Reddit API expects the full ID (e.g., "t1_n1lqt5s") for thing_id when
			// replying to a comment.
			// Assuming thingId passed here is the base ID, prefix it with "t1_".
			String fullThingId = "t1_" + thingId;
			String postBody = "api_type=json" + "&text="
					+ URLEncoder.encode(replyText, StandardCharsets.UTF_8.toString()) + "&thing_id="
					+ URLEncoder.encode(fullThingId, StandardCharsets.UTF_8.toString());

			try (OutputStream os = conn.getOutputStream()) {
				os.write(postBody.getBytes(StandardCharsets.UTF_8));
			}

			StringBuilder responseBuilder = new StringBuilder();
			int responseCode = conn.getResponseCode();
			System.out.println("HTTP Response Code for reply to " + fullThingId + ": " + responseCode);

			InputStream responseStream = null;
			if (responseCode >= 200 && responseCode < 300) {
				responseStream = conn.getInputStream();
			} else {
				responseStream = conn.getErrorStream();
			}

			if (responseStream != null) {
				try (BufferedReader in = new BufferedReader(new InputStreamReader(responseStream))) {
					String line;
					while ((line = in.readLine()) != null) {
						responseBuilder.append(line);
					}
				}
			}
			String responseBody = responseBuilder.toString();
			System.out.println("Reply Response Body: " + responseBody);

			if (responseCode == HttpURLConnection.HTTP_OK || responseCode == HttpURLConnection.HTTP_CREATED) {
				JSONObject jsonResponse = new JSONObject(responseBody);
				JSONObject json = jsonResponse.optJSONObject("json");
				if (json != null) {
					if (json.has("errors") && json.getJSONArray("errors").length() > 0) {
						System.err.println("API Errors during reply: " + json.getJSONArray("errors").toString());
						return false;
					} else if (json.has("data") && json.optJSONObject("data").has("things")) {
						return true; // Successfully posted comment
					}
				}
				return true; // Consider 2xx as success even if JSON structure is unexpected
			} else {
				System.err.println("HTTP Error during reply: " + responseCode + " - " + conn.getResponseMessage());
				return false;
			}

		} catch (MalformedURLException e) {
			System.err.println("Malformed URL Exception: " + e.getMessage());
			e.printStackTrace();
		} catch (ProtocolException e) {
			System.err.println("Protocol Exception: " + e.getMessage());
			e.printStackTrace();
		} catch (IOException e) {
			System.err.println("IO Exception: " + e.getMessage());
			e.printStackTrace();
		} catch (URISyntaxException e) {
			System.err.println("URI Syntax Exception: " + e.getMessage());
			e.printStackTrace();
		} finally {
			if (conn != null) {
				conn.disconnect();
			}
		}
		return false; // Default return for any unhandled exception or failure
	}

	/**
	 * Calculates total characters and total 'h' characters in an array of comments.
	 *
	 * @param comments An array of comment strings.
	 * @return A long array where index 0 is total characters and index 1 is total
	 *         'h' characters.
	 */
	private long[] getCommentInfo(String[] comments) {
		long totalChars = 0;
		long totalH = 0;
		for (String comment : comments) {
			totalChars += comment.length();
			totalH += comment.length() - comment.toLowerCase().replace("h", "").length();
		}
		return new long[] { totalChars, totalH };
	}

	/**
	 * Fetches comments made by a specific Reddit user.
	 *
	 * @param author The username of the author whose comments to fetch.
	 * @return An array of comment bodies as strings.
	 */
	private String[] getUserComments(String author) {
		String url = "https://www.reddit.com/user/" + author + "/comments/.json?limit=1000"; // Max limit is 1000
		HttpURLConnection conn = null;
		try {
			URL apiUrl = new URI(url).toURL();
			conn = (HttpURLConnection) apiUrl.openConnection();
			conn.setRequestMethod("GET");
			conn.setRequestProperty("User-Agent", user_agent); // Essential for Reddit API

			int responseCode = conn.getResponseCode();
			if (responseCode != HttpURLConnection.HTTP_OK) {
				System.err.println("Error fetching user comments for " + author + ": " + responseCode + " - "
						+ conn.getResponseMessage());
				return new String[0];
			}

			BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
			String line;
			StringBuilder response = new StringBuilder();
			while ((line = in.readLine()) != null)
				response.append(line);
			in.close();

			JSONObject jsonResponse = new JSONObject(response.toString());
			JSONArray commentsArray = jsonResponse.getJSONObject("data").getJSONArray("children");

			String[] comments = new String[commentsArray.length()];
			for (int i = 0; i < commentsArray.length(); i++) {
				comments[i] = commentsArray.getJSONObject(i).getJSONObject("data").getString("body");
			}
			return comments;
		} catch (MalformedURLException e) {
			System.err.println("Malformed URL Exception in getUserComments: " + e.getMessage());
			e.printStackTrace();
		} catch (ProtocolException e) {
			System.err.println("Protocol Exception in getUserComments: " + e.getMessage());
			e.printStackTrace();
		} catch (IOException e) {
			System.err.println("IO Exception in getUserComments: " + e.getMessage());
			e.printStackTrace();
		} catch (URISyntaxException e) {
			System.err.println("URI Syntax Exception in getUserComments: " + e.getMessage());
			e.printStackTrace();
		} finally {
			if (conn != null) {
				conn.disconnect();
			}
		}
		return new String[0];
	}

	/**
	 * Fetches unread messages from Reddit and filters them to return only username
	 * mentions. It also marks all processed messages (mentions or non-mentions) as
	 * read.
	 *
	 * @return A List of String arrays, where each array contains [id, author,
	 *         targetUser, fullname].
	 */
	public List<String[]> getUnreadMessagesAndFilterMentions() {
		HttpURLConnection conn = null;
		List<String[]> filteredMentions = new ArrayList<>(); // Use a List to dynamically add valid mentions

		try {
			// This endpoint fetches all unread messages (mentions, DMs, etc.)
			URL url = new URI("https://oauth.reddit.com/message/unread").toURL();
			conn = (HttpURLConnection) url.openConnection();

			conn.setRequestMethod("GET");
			// conn.setDoOutput(true); // Removed: GET requests generally don't send output
			conn.setRequestProperty("Authorization", "Bearer " + token);
			conn.setRequestProperty("User-Agent", user_agent);

			StringBuilder responseBuilder = new StringBuilder();
			int responseCode = conn.getResponseCode();

			InputStream is;
			if (responseCode >= 200 && responseCode < 300) {
				is = conn.getInputStream();
			} else {
				is = conn.getErrorStream();
			}

			try (BufferedReader in = new BufferedReader(new InputStreamReader(is))) {
				String line;
				while ((line = in.readLine()) != null) {
					responseBuilder.append(line);
				}
			}

			String response = responseBuilder.toString();
			System.out.println("Unread Messages API Response (first 500 chars): "
					+ (response.length() > 500 ? response.substring(0, 500) + "..." : response));

			JSONObject jsonResponse = new JSONObject(response);

			if (jsonResponse.has("data")) {
				JSONObject data = jsonResponse.getJSONObject("data");

				if (data.has("children")) {
					JSONArray children = data.getJSONArray("children");

					for (int i = 0; i < children.length(); i++) {
						JSONObject child = children.getJSONObject(i);
						JSONObject message = child.getJSONObject("data");

						String messageFullname = message.getString("name"); // e.g., "t1_n1lqt5s" or "t4_36efp96"
						String messageId = message.getString("id"); // e.g., "n1lqt5s" or "36efp96"

						// Check if this message has already been processed in a previous run
						if (processedMessageFullnames.contains(messageFullname)) {
							System.out.println("Skipping already processed message: " + messageFullname);
							// Even if already processed, if it's still unread, mark it as read again.
							markMessageAsRead(messageFullname);
							continue;
						}

						// Filtering logic: Only process if it's a username mention AND a comment
						boolean isUsernameMention = message.has("type")
								&& "username_mention".equals(message.getString("type"));
						boolean isComment = message.has("was_comment") && message.getBoolean("was_comment");

						if (isUsernameMention && isComment) {
							// This is a valid mention we want to process
							String author = message.getString("author");
							String body = message.getString("body").toLowerCase().replace("u/h-counter-bot", "").trim();

							String targetUser;
							if (body.contains("[self]")) {
								targetUser = author;
							} else if (body.contains("u/")) {
								int start = body.indexOf("u/") + 2;
								int end = body.indexOf(" ", start);
								if (end == -1) {
									end = body.length();
								}
								// Clean up the username, remove trailing punctuation if any
								targetUser = body.substring(start, end);
								targetUser = targetUser.replaceAll("[^a-zA-Z0-9_-]", "");
							} else {
								targetUser = getOP(message.getString("context"));
								if (targetUser == null) {
									System.err.println("Could not determine target user for mention ID: " + messageId
											+ ". Skipping.");
									// Mark as read and skip if target user cannot be determined
									markMessageAsRead(messageFullname);
									processedMessageFullnames.add(messageFullname);
									saveProcessedMessageFullnames();
									continue;
								}
							}
							// Add the valid mention details to our list
							filteredMentions.add(new String[] { messageId, author, targetUser, messageFullname });
						} else {
							// This is not a username mention comment (e.g., a DM), so mark it as read and
							// skip
							System.out.println("Skipping non-mention message: " + messageFullname + " (Type: "
									+ (message.has("type") ? message.getString("type") : "N/A") + ", WasComment: "
									+ (message.has("was_comment") ? message.getBoolean("was_comment") : "N/A") + ")");
							markMessageAsRead(messageFullname);
							processedMessageFullnames.add(messageFullname); // Add to our set
							saveProcessedMessageFullnames(); // Persist the updated set
						}
					}
				}
			}
		} catch (MalformedURLException e) {
			System.err.println("Malformed URL Exception in getUnreadMessagesAndFilterMentions: " + e.getMessage());
			e.printStackTrace();
		} catch (ProtocolException e) {
			System.err.println("Protocol Exception in getUnreadMessagesAndFilterMentions: " + e.getMessage());
			e.printStackTrace();
		} catch (IOException e) {
			System.err.println("IO Exception in getUnreadMessagesAndFilterMentions: " + e.getMessage());
			e.printStackTrace();
		} catch (URISyntaxException e) {
			System.err.println("URI Syntax Exception in getUnreadMessagesAndFilterMentions: " + e.getMessage());
			e.printStackTrace();
		} catch (Exception e) { // Catch any other unexpected JSON or runtime exceptions
			System.err.println("An unexpected error occurred in getUnreadMessagesAndFilterMentions: " + e.getMessage());
			e.printStackTrace();
		} finally {
			if (conn != null) {
				conn.disconnect();
			}
		}
		return filteredMentions; // Return the list of valid mentions
	}

	/**
	 * Retrieves the original poster (OP) of a submission given a context URL.
	 *
	 * @param context The context URL of a comment (e.g.,
	 *                "/r/subreddit/comments/post_id/comment_id/?context=3").
	 * @return The username of the original poster, or null if not found or an error
	 *         occurs.
	 */
	private String getOP(String context) {
		String op = null;
		// Example context: /r/subreddit/comments/post_id/comment_id/
		String[] parts = context.strip().split("/");
		// Ensure enough parts to extract subreddit and post ID
		if (parts.length < 5) {
			System.err.println("Invalid context for getOP (too short): " + context);
			return null;
		}
		String subreddit = parts[2];
		String postId = parts[4]; // The submission ID

		URL url;
		HttpURLConnection conn = null;
		try {
			url = new URI("https://www.reddit.com/r/" + subreddit + "/comments/" + postId + "/.json").toURL();

			conn = (HttpURLConnection) url.openConnection();
			conn.setRequestMethod("GET");
			conn.setRequestProperty("User-Agent", user_agent); // Essential for Reddit API

			int responseCode = conn.getResponseCode();
			if (responseCode != HttpURLConnection.HTTP_OK) {
				System.err.println("Error getting OP for context " + context + ": " + responseCode + " - "
						+ conn.getResponseMessage());
				// Read error stream for more details
				try (BufferedReader errorReader = new BufferedReader(new InputStreamReader(conn.getErrorStream()))) {
					String line;
					StringBuilder errorResponse = new StringBuilder();
					while ((line = errorReader.readLine()) != null) {
						errorResponse.append(line);
					}
					System.err.println("getOP Error Response: " + errorResponse.toString());
				}
				return null;
			}

			BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
			String line;
			StringBuilder response = new StringBuilder();
			while ((line = in.readLine()) != null)
				response.append(line);
			in.close();

			JSONArray jsonArrayResponse = new JSONArray(response.toString());
			// The first element of the array is the submission itself
			JSONObject submissionData = jsonArrayResponse.getJSONObject(0).getJSONObject("data")
					.getJSONArray("children").getJSONObject(0).getJSONObject("data");
			op = submissionData.getString("author");
		} catch (MalformedURLException e) {
			System.err.println("Malformed URL Exception in getOP: " + e.getMessage());
			e.printStackTrace();
		} catch (ProtocolException e) {
			System.err.println("Protocol Exception in getOP: " + e.getMessage());
			e.printStackTrace();
		} catch (IOException e) {
			System.err.println("IO Exception in getOP: " + e.getMessage());
			e.printStackTrace();
		} catch (URISyntaxException e) {
			System.err.println("URI Syntax Exception in getOP: " + e.getMessage());
			e.printStackTrace();
		} catch (Exception e) { // Catch any other unexpected JSON or runtime exceptions
			System.err.println("An unexpected error occurred in getOP: " + e.getMessage());
			e.printStackTrace();
		} finally {
			if (conn != null) {
				conn.disconnect();
			}
		}
		return op;
	}

	/**
	 * Obtains an OAuth2 access token from Reddit using username/password grant
	 * type.
	 *
	 * @return The access token string, or null if an error occurs.
	 */
	private String getAccessToken() {
		HttpURLConnection conn = null;
		try {
			String auth = clientId + ":" + clientSecret;
			String encodedAuth = Base64.getEncoder().encodeToString(auth.getBytes());

			// Use www.reddit.com for token endpoint
			URL url = new URI("https://www.reddit.com/api/v1/access_token").toURL();
			conn = (HttpURLConnection) url.openConnection();

			conn.setRequestMethod("POST");
			conn.setDoOutput(true);
			conn.setRequestProperty("Authorization", "Basic " + encodedAuth);
			conn.setRequestProperty("User-Agent", user_agent);
			conn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");

			String body = "grant_type=password&username=" + URLEncoder.encode(username, "UTF-8") + "&password="
					+ URLEncoder.encode(password, "UTF-8");

			try (OutputStream os = conn.getOutputStream()) {
				os.write(body.getBytes());
			}

			int responseCode = conn.getResponseCode();
			if (responseCode != HttpURLConnection.HTTP_OK) {
				System.err.println("Error getting access token: " + responseCode + " - " + conn.getResponseMessage());
				// Read error stream for more details
				try (BufferedReader errorReader = new BufferedReader(new InputStreamReader(conn.getErrorStream()))) {
					String line;
					StringBuilder errorResponse = new StringBuilder();
					while ((line = errorReader.readLine()) != null) {
						errorResponse.append(line);
					}
					System.err.println("Access Token Error Response Body: " + errorResponse.toString());
				}
				return null;
			}

			BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
			String line;
			StringBuilder response = new StringBuilder();
			while ((line = in.readLine()) != null)
				response.append(line);
			in.close();

			return new JSONObject(response.toString()).getString("access_token");
		} catch (MalformedURLException e) {
			System.err.println("Malformed URL Exception in getAccessToken: " + e.getMessage());
			e.printStackTrace();
		} catch (ProtocolException e) {
			System.err.println("Protocol Exception in getAccessToken: " + e.getMessage());
			e.printStackTrace();
		} catch (IOException e) {
			System.err.println("IO Exception in getAccessToken: " + e.getMessage());
			e.printStackTrace();
		} catch (URISyntaxException e) {
			System.err.println("URI Syntax Exception in getAccessToken: " + e.getMessage());
			e.printStackTrace();
		} catch (Exception e) { // Catch any other unexpected JSON or runtime exceptions
			System.err.println("An unexpected error occurred in getAccessToken: " + e.getMessage());
			e.printStackTrace();
		} finally {
			if (conn != null) {
				conn.disconnect();
			}
		}
		return null;
	}

	// --- Helper methods for loading and saving processed IDs ---

	/**
	 * Loads previously processed message fullnames from a file into the HashSet.
	 */
	private void loadProcessedMessageFullnames() {
		try (BufferedReader reader = new BufferedReader(new FileReader(PROCESSED_IDS_FILE))) {
			String line;
			while ((line = reader.readLine()) != null) {
				processedMessageFullnames.add(line.trim());
			}
			System.out.println("Loaded " + processedMessageFullnames.size() + " processed message fullnames.");
		} catch (IOException e) {
			System.out.println("No existing processed messages file found (" + PROCESSED_IDS_FILE
					+ "). Starting with an empty list.");
			// This is fine, means the bot is running for the first time or file was
			// deleted.
		}
	}

	/**
	 * Saves the current set of processed message fullnames to a file.
	 */
	private void saveProcessedMessageFullnames() {
		try (BufferedWriter writer = new BufferedWriter(new FileWriter(PROCESSED_IDS_FILE))) {
			for (String fullname : processedMessageFullnames) {
				writer.write(fullname);
				writer.newLine();
			}
			System.out.println("Saved " + processedMessageFullnames.size() + " processed message fullnames.");
		} catch (IOException e) {
			System.err.println(
					"Error saving processed message fullnames to " + PROCESSED_IDS_FILE + ": " + e.getMessage());
			e.printStackTrace();
		}
	}
}
